# Copyright 2014 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//gn/core/config/android/env.gni")
import("//gn/addon/android_app/ijar/ijar.gni")

assert(is_android)

rebased_android_sdk = rebase_path(android_sdk, root_build_dir)
rebased_android_sdk_root = rebase_path(android_sdk_root, root_build_dir)
rebased_android_sdk_build_tools =
    rebase_path(android_sdk_build_tools, root_build_dir)

android_sdk_jar = "$android_sdk/android.jar"
rebased_android_sdk_jar = rebase_path(android_sdk_jar, root_build_dir)
android_aapt_path = "$rebased_android_sdk_build_tools/aapt"

android_configuration_name = "Release"
if (is_debug) {
  android_configuration_name = "Debug"
}

# Write the target's .build_config file. This is a json file that contains a
# dictionary of information about how to build this target (things that
# require knowledge about this target's dependencies and cannot be calculated
# at gn-time). There is a special syntax to add a value in that dictionary to
# an action/action_foreachs args:
#   --python-arg=@FileArg($rebased_build_config_path:key0:key1)
# At runtime, such an arg will be replaced by the value in the build_config.
# See build/android/gyp/write_build_config.py and
# build/android/gyp/util/build_utils.py:ExpandFileArgs
#
# Variables
#   dpes:
#
#   build_config: Output path for the generated build_config
#
#   type: android_apk, android_resources, java_library, deps_dex
#   srcjar
#   jar_path
#   android_manifest
#   dex_path
#   resources_zip
#   r_text
#   native_libs
#   supports_android
#   requires_android
#   custom_package
#   bypass_platform_checks
#   apk_under_test
#
template("write_build_config") {
  set_sources_assignment_filter([])

  assert(defined(invoker.type))
  assert(defined(invoker.build_config))

  type = invoker.type
  build_config = invoker.build_config

  assert(type == "android_apk" || type == "java_library" ||
         type == "android_resources" || type == "deps_dex")

  action(target_name) {
    deps = []
    forward_variables_from(invoker,
                           [
                             "deps",
                             "testonly",
                             "visibility",
                           ])

    script = "//gn/addon/android_app/write_build_config.py"
    depfile = "$target_gen_dir/$target_name.d"
    inputs = []

    possible_deps_configs = []
    foreach(d, deps) {
      dep_gen_dir = get_label_info(d, "target_gen_dir")
      dep_name = get_label_info(d, "name")
      possible_deps_configs += [ "$dep_gen_dir/$dep_name.build_config" ]
    }
    rebase_possible_deps_configs =
        rebase_path(possible_deps_configs, root_build_dir)

    outputs = [
      depfile,
      build_config,
    ]

    args = [
      "--type",
      type,
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--possible-deps-configs=$rebase_possible_deps_configs",
      "--build-config",
      rebase_path(build_config, root_build_dir),
    ]

    is_java_library = type == "java_library"
    is_apk = type == "android_apk"
    is_android_resources = type == "android_resources"
    is_deps_dex = type == "deps_dex"

    supports_android = is_apk || is_android_resources || is_deps_dex ||
                       (is_java_library && defined(invoker.supports_android) &&
                        invoker.supports_android)
    requires_android = is_apk || is_android_resources || is_deps_dex ||
                       (is_java_library && defined(invoker.requires_android) &&
                        invoker.requires_android)

    assert(!requires_android || supports_android,
           "requires_android requires" + " supports_android")

    # Mark these variables as used.
    assert(is_java_library || true)
    assert(is_apk || true)
    assert(is_android_resources || true)
    assert(is_deps_dex || true)

    if (is_java_library || is_apk) {
      args += [
        "--jar-path",
        rebase_path(invoker.jar_path, root_build_dir),
      ]
    }

    if (defined (invoker.dex_path) && (is_apk || is_deps_dex || (is_java_library && supports_android))) {
      args += [
        "--dex-path",
        rebase_path(invoker.dex_path, root_build_dir),
      ]
    }
    if (supports_android) {
      args += [ "--supports-android" ]
    }
    if (requires_android) {
      args += [ "--requires-android" ]
    }
    if (defined(invoker.bypass_platform_checks) &&
        invoker.bypass_platform_checks) {
      args += [ "--bypass-platform-checks" ]
    }

    if (defined(invoker.apk_under_test)) {
      deps += [ invoker.apk_under_test ]
      apk_under_test_gen_dir =
          get_label_info(invoker.apk_under_test, "target_gen_dir")
      apk_under_test_name = get_label_info(invoker.apk_under_test, "name")
      apk_under_test_config =
          "$apk_under_test_gen_dir/$apk_under_test_name.build_config"
      args += [
        "--tested-apk-config",
        rebase_path(apk_under_test_config, root_build_dir),
      ]
    }

    if (is_android_resources || is_apk) {
      assert(defined(invoker.resources_zip))
      args += [
        "--resources-zip",
        rebase_path(invoker.resources_zip, root_build_dir),
      ]
      if (defined(invoker.android_manifest)) {
        inputs += [ invoker.android_manifest ]
        args += [
          "--android-manifest",
          rebase_path(invoker.android_manifest, root_build_dir),
        ]
      } else {
        assert(!is_apk, "apk build configs require an android_manifest")
      }
      if (defined(invoker.custom_package)) {
        args += [
          "--package-name",
          invoker.custom_package,
        ]
      }
      if (defined(invoker.r_text)) {
        args += [
          "--r-text",
          rebase_path(invoker.r_text, root_build_dir),
        ]
      }
    }

    if (is_apk) {
      if (defined(invoker.native_libs)) {
        inputs += invoker.native_libs
        rebased_native_libs = rebase_path(invoker.native_libs, root_build_dir)
        rebased_android_readelf = rebase_path(android_readelf, root_build_dir)
        args += [
          "--native-libs=$rebased_native_libs",
          "--readelf-path=$rebased_android_readelf",
        ]
      }
    }

    if (defined(invoker.srcjar)) {
      args += [
        "--srcjar",
        rebase_path(invoker.srcjar, root_build_dir),
      ]
    }
  }
}

# Write build_config for android apk build.
# Copy all native libs dependency to output_native_libs_dir/$android_app_abi.
#
# Variables
#   deps: Specifies the dependencies of this target.
#   native_libs:
#
#   build_config: Output path for the generated build_config
#   output_native_libs_dir: New directory containing packed native libraries.
#
#   jar_path
#   dex_path
#   resources_zip
#   android_manifest
#
template("organize_apk_build") {
  assert(defined(invoker.build_config))
  forward_variables_from(invoker,
             [
               "deps",
               "native_libs",
               "build_config",

               "data_deps",
               "public_deps",
             ])

  build_config_target_name = "${target_name}__build_config"
  native_libs_target_name = "${target_name}__native_libs"
  final_target_name = target_name
  final_group_dep = [ ":$build_config_target_name" ]

  write_build_config(build_config_target_name) {
    forward_variables_from(invoker, [ 
      "apk_under_test",
      "jar_path",
      "dex_path",
      "resources_zip",
      "android_manifest",
    ])
    type = "android_apk"
    visibility = [
      ":$native_libs_target_name",
      ":$final_target_name",
    ]
  }

  assert(invoker.output_native_libs_dir != "" || true)  # Mark as used.
  if (defined(native_libs) && native_libs != []) {
    final_group_dep += [ ":$native_libs_target_name" ]
    action(native_libs_target_name) {
      visibility = [ ":$final_target_name" ]
      script = "//gn/addon/android_app/pack_relocations.py"
      packed_libraries_dir = "${invoker.output_native_libs_dir}/$android_app_abi"
      depfile = "$target_gen_dir/$target_name.d"
      outputs = [
        depfile,
      ]

      inputs = native_libs

      inputs += [ build_config ]
      deps += [ ":$build_config_target_name" ]

      skip_packing_list = [
        "gdbserver",
      ]

      _rebased_build_config = rebase_path(build_config, root_build_dir)
      args = [
        "--depfile",
        rebase_path(depfile, root_build_dir),
        "--enable-packing=0",
        "--exclude-packing-list=$skip_packing_list",
        "--stripped-libraries-dir",
        rebase_path(root_build_dir, root_build_dir),
        "--packed-libraries-dir",
        rebase_path(packed_libraries_dir, root_build_dir),
        "--libraries=@FileArg(${_rebased_build_config}:native:libraries)",
        "--clear-dir",
      ]

      if (is_debug) {
        rebased_gdbserver = rebase_path([ android_gdbserver ], root_build_dir)
        inputs += [ android_gdbserver ]
        args += [ "--libraries=$rebased_gdbserver" ]
      }
    }
  }

  group(final_target_name) {
    forward_variables_from(invoker, [ "visibility" ])
    public_deps = final_group_dep
  }
}

# Process Android resources to generate R.java
#
# Variables
#   deps: Specifies the dependencies of this target.
#   build_config:
#   resource_dirs:
#   android_manifest:
#
#   zip_path: Output path for the packed resource.
#   all_resources_zip_path:
#   srcjar_path: Output path for the generated R.java
#   r_text_path:
#
#   v14-skip
#   shared-resources
#   dependencies-res-zips
#   extra-res-packages
#
template("process_resources") {
  set_sources_assignment_filter([])
  forward_variables_from(invoker, [ "testonly" ])

  zip_path = invoker.zip_path
  srcjar_path = invoker.srcjar_path
  r_text_path = invoker.r_text_path
  build_config = invoker.build_config
  resource_dirs = invoker.resource_dirs
  android_manifest = invoker.android_manifest

  non_constant_id = true
  if (defined(invoker.generate_constant_ids) && invoker.generate_constant_ids) {
    non_constant_id = false
  }

  action(target_name) {
    forward_variables_from(invoker,
                           [
                             "deps",
                             "visibility",
                           ])
    script = "//gn/addon/android_app/process_resources.py"

    depfile = "$target_gen_dir/$target_name.d"
    outputs = [
      depfile,
      zip_path,
      srcjar_path,
      r_text_path,
    ]

    sources_build_rel = exec_script("//gn/script/find.py",
                                    rebase_path(resource_dirs, root_build_dir),
                                    "list lines")
    sources = rebase_path(sources_build_rel, ".", root_build_dir)

    inputs = [
      build_config,
      android_manifest,
    ]

    rebase_resource_dirs = rebase_path(resource_dirs, root_build_dir)
    rebase_build_config = rebase_path(build_config, root_build_dir)
    args = [
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--android-sdk",
      rebase_path(android_sdk, root_build_dir),
      "--aapt-path",
      android_aapt_path,
      "--android-manifest",
      rebase_path(android_manifest, root_build_dir),
      "--resource-dirs=$rebase_resource_dirs",
      "--srcjar-out",
      rebase_path(srcjar_path, root_build_dir),
      "--resource-zip-out",
      rebase_path(zip_path, root_build_dir),
      "--r-text-out",
      rebase_path(r_text_path, root_build_dir),
      "--dependencies-res-zips=@FileArg($rebase_build_config:resources:dependency_zips)",
      "--extra-res-packages=@FileArg($rebase_build_config:resources:extra_package_names)",
      "--extra-r-text-files=@FileArg($rebase_build_config:resources:extra_r_text_files)",
    ]

    if (non_constant_id) {
      args += [ "--non-constant-id" ]
    }

    if (defined(invoker.custom_package)) {
      args += [
        "--custom-package",
        invoker.custom_package,
      ]
    }

    if (defined(invoker.v14_skip) && invoker.v14_skip) {
      args += [ "--v14-skip" ]
    }

    if (defined(invoker.shared_resources) && invoker.shared_resources) {
      args += [ "--shared-resources" ]
    }

    if (defined(invoker.all_resources_zip_path)) {
      all_resources_zip = invoker.all_resources_zip_path
      outputs += [ all_resources_zip ]
      args += [
        "--all-resources-zip-out",
        rebase_path(all_resources_zip, root_build_dir),
      ]
    }

    if (defined(invoker.args)) {
      args += invoker.args
    }
  }
}

# Creates an asset and reaource packaged apk(.ap_)
#
# Variables
#   deps: Specifies the dependencies of this target.
#   asset_dir: The path of asset
#   resources_zip: android resource
#   android_manifest: The path of manifest
#   version_code:
#   version_name:
#   shared_resources:
#   create_density_splits:
#   split_languages:
#   extensions_to_not_compress: These are actually suffix matches, not necessarily extensions.
#
#   output_resource_packaged_apk_path: Output path for the generated .ap_
template("package_asset_ap_") {
  action(target_name) {
    deps = invoker.deps

    script = "//gn/addon/android_app/package_asset_ap.py"
    depfile = "${target_gen_dir}/${target_name}.d"
    inputs = [
      invoker.android_manifest,
    ]
    if (defined(invoker.resources_zip)) {
      inputs += [ invoker.resources_zip ]
    }
    outputs = [
      depfile,
      invoker.output_resource_packaged_apk_path,
    ]

    args = [
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--android-sdk",
      rebased_android_sdk,
      "--aapt-path",
      android_aapt_path,
      "--configuration-name=$android_configuration_name",
      "--android-manifest",
      rebase_path(invoker.android_manifest, root_build_dir),
      "--version-code",
      invoker.version_code,
      "--version-name",
      invoker.version_name,
      "--apk-path",
      rebase_path(invoker.output_resource_packaged_apk_path, root_build_dir),
    ]

    if (defined(invoker.asset_dir)) {
      args += [
        "--asset-dir",
        rebase_path(invoker.asset_dir, root_build_dir),
      ]
    }
    if (defined(invoker.resources_zip)) {
      args += [
        "--resource-zips",
        rebase_path(invoker.resources_zip, root_build_dir),
      ]
    }
    if (defined(invoker.shared_resources) && invokder.shared_resources) {
      args += [ "--shared-resources" ]
    }

    if (defined(invoker.create_density_splits) && invoker.create_density_splits) {
      _split_densities = [
        "hdpi",
        "xhdpi",
        "xxhdpi",
        "xxxhdpi",
        "tvdpi",
      ]
      args += [ "--create-density-splits" ]
      foreach(_density, _split_densities) {
        outputs += [ "${invoker.resource_packaged_apk_path}_${_density}" ]
      }
    }
    if (defined(invoker.language_splits)) {
      args += [ "--language-splits=$_split_languages" ]
      foreach(_language, invoker.split_languages) {
        outputs += [ "${invoker.resource_packaged_apk_path}_${_language}" ]
      }
    }
    if (defined(invoker.extensions_to_not_compress)) {
      args += [
        "--no-compress",
        invoker.extensions_to_not_compress,
      ]
    }
  }
}

# Add aditional resource to packaged apk(.ap_)
#
# Variables
#   deps: Specifies the dependencies of this target.
#   resource_packaged_apk_path:
#   sources:
#
template("add_asset_ap_") {
  action(target_name) {
    deps = invoker.deps

    script = "//gn/addon/android_app/add_asset_ap.py"
    depfile = "${target_gen_dir}/${target_name}.d"
    inputs = invoker.sources
    outputs = [
      depfile,
      invoker.resource_packaged_apk_path,
    ]

    args = [
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--android-sdk",
      rebased_android_sdk,
      "--aapt-path",
      android_aapt_path,
      "--ap-path",
      rebase_path(invoker.resource_packaged_apk_path, root_build_dir),
    ]

    if (defined(invoker.args)) {
      args += invoker.args
    }

    args += rebase_path(invoker.sources, root_build_dir)
  }
}

# Dex java code.
#
# Variables
#   deps:
#   sources:
#
#   output:
#
#   no_locals:
#   args:
#
template("dex") {
  set_sources_assignment_filter([])

  assert(defined(invoker.output))
  action(target_name) {
    forward_variables_from(invoker,
                           [
                             "deps",
                             "inputs",
                             "sources",
                             "testonly",
                           ])
    script = "//gn/addon/android_app/dex.py"
    depfile = "$target_gen_dir/$target_name.d"
    outputs = [
      depfile,
      invoker.output,
    ]

    rebased_output = rebase_path(invoker.output, root_build_dir)

    args = [
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--android-sdk-tools",
      rebased_android_sdk_build_tools,
      "--dex-path",
      rebased_output,
    ]

    if (incremental_dx) {
      args += [ "--incremental" ]
    }

    if (defined(invoker.no_locals) && invoker.no_locals) {
      args += [ "--no-locals=1" ]
    }

    if (defined(invoker.args)) {
      args += invoker.args
    }

    if (defined(invoker.sources)) {
      args += rebase_path(invoker.sources, root_build_dir)
    }
  }
}

# Creates an unsigned .apk.
#
# Variables
#   deps: Specifies the dependencies of this target.
#   dex_path: Path to classes.dex file to include (optional).
#   resource_packaged_apk_path: Path to .ap_ to use.
#   native_libs_dir: Directory containing native libraries.
#
#   output_apk_path: Output path for the generated .apk.
#
template("package_apk") {
  action(target_name) {
    forward_variables_from(invoker,
                           [
                             "deps",
                             "public_deps",
                             "testonly",
                           ])
    script = "//gn/addon/android_app/apkbuilder.py"
    depfile = "$target_gen_dir/$target_name.d"

    inputs = [
      invoker.resource_packaged_apk_path,
    ]
    if (defined(invoker.dex_path)) {
      inputs += [ invoker.dex_path ]
    }

    outputs = [
      depfile,
      invoker.output_apk_path,
    ]

    _rebased_resource_packaged_apk_path =
        rebase_path(invoker.resource_packaged_apk_path, root_build_dir)
    _rebased_packaged_apk_path =
        rebase_path(invoker.output_apk_path, root_build_dir)
    args = [
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--resource-apk=$_rebased_resource_packaged_apk_path",
      "--output-apk=$_rebased_packaged_apk_path",
    ]
    if (defined(invoker.dex_path)) {
      _rebased_dex_path = rebase_path(invoker.dex_path, root_build_dir)
      args += [ "--dex-file=$_rebased_dex_path" ]
    }
    if (defined(invoker.native_libs_dir)) {
      _rebased_native_libs_dir =
          rebase_path(invoker.native_libs_dir, root_build_dir)
      args += [
        "--native-libs-dir=$_rebased_native_libs_dir/$android_app_abi",
        "--android-abi=$android_app_abi",
      ]
    }
  }
}

# Signs & zipaligns an apk.
#
# Variables
#   input_apk_path: Path of the .apk to be finalized.
#   output_apk_path: Output path for the generated .apk.
#   keystore_path: Path to keystore to use for signing.
#   keystore_name: Key alias to use.
#   keystore_password: Keystore password.
#   rezip_apk: Whether to add crazy-linker alignment.
template("finalize_apk") {
  action(target_name) {
    script = "//gn/addon/android_app/finalize_apk.py"
    depfile = "$target_gen_dir/$target_name.d"
    forward_variables_from(invoker,
                           [
                             "deps",
                             "data_deps",
                             "public_deps",
                             "testonly",
                           ])

    sources = [
      invoker.input_apk_path,
    ]
    inputs = [
      invoker.keystore_path,
    ]
    outputs = [
      depfile,
      invoker.output_apk_path,
    ]

    args = [
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--zipalign-path",
      rebase_path(zipalign_path, root_build_dir),
      "--unsigned-apk-path",
      rebase_path(invoker.input_apk_path, root_build_dir),
      "--final-apk-path",
      rebase_path(invoker.output_apk_path, root_build_dir),
      "--key-path",
      rebase_path(invoker.keystore_path, root_build_dir),
      "--key-name",
      invoker.keystore_name,
      "--key-passwd",
      invoker.keystore_password,
    ]
    if (defined(invoker.rezip_apk) && invoker.rezip_apk) {
      _rezip_jar_path = "$root_build_dir/lib.java/rezip_apk.jar"
      inputs += [ _rezip_jar_path ]
      args += [
        "--load-library-from-zip=1",
        "--rezip-apk-jar-path",
        rebase_path(_rezip_jar_path, root_build_dir),
      ]
    }
  }
}

# Packages resources, assets, dex, and native libraries into an apk. Signs and
# zipaligns the apk.
# package_asset_ap_ + package_apk + finalize_apk
#
# Variables
#   deps: Specifies the dependencies of this target.
#   base_path:
#   dex_path:
#
#   apk_path: Output path for the generated .apk.
#
template("create_apk") {
  set_sources_assignment_filter([])
  forward_variables_from(invoker, [ "testonly" ])

  _base_path = invoker.base_path
  _final_apk_path = invoker.apk_path
  if (incremental_install) {
  _incremental_final_apk_path_helper =
      process_file_template(
          [ _final_apk_path ],
          "{{source_dir}}/{{source_name_part}}_incremental.apk")
  _incremental_final_apk_path = _incremental_final_apk_path_helper[0]
  }

  if (defined(invoker.dex_path)) {
    _dex_path = invoker.dex_path
  }
  _load_library_from_apk = invoker.load_library_from_apk

  _deps = []
  if (defined(invoker.deps)) {
    _deps = invoker.deps
  }
  if (incremental_install) {
  _incremental_deps = []
  if (defined(invoker.incremental_deps)) {
    _incremental_deps = invoker.incremental_deps
  }
  }

  _version_code = invoker.version_code
  _version_name = invoker.version_name
  assert(_version_code != -1)  # Mark as used.
  assert(_version_name != "")  # Mark as used.

  _base_apk_path = _base_path + ".apk_intermediates"

  _split_densities = []
  if (defined(invoker.create_density_splits) && invoker.create_density_splits) {
    _split_densities = [
      "hdpi",
      "xhdpi",
      "xxhdpi",
      "xxxhdpi",
      "tvdpi",
    ]
  }

  _split_languages = []
  if (defined(invoker.language_splits)) {
    _split_languages = invoker.language_splits
  }


  _resource_packaged_apk_path = _base_apk_path + ".ap_"
  _packaged_apk_path = _base_apk_path + ".unfinished.apk"
  if (incremental_install) {
  _incremental_resource_packaged_apk_path = _base_apk_path + "_incremental.ap_"
  _incremental_packaged_apk_path =
      _base_apk_path + "_incremental.unfinished.apk"
  }
  _shared_resources =
      defined(invoker.shared_resources) && invoker.shared_resources
  assert(_shared_resources || true)  # Mark as used.

  _keystore_path = invoker.keystore_path
  _keystore_name = invoker.keystore_name
  _keystore_password = invoker.keystore_password

  _package_resources_target_name = "${target_name}__package_resources"
  package_asset_ap_(_package_resources_target_name) {
    forward_variables_from(invoker, [
      "deps",
      "resources_zip",
      "android_manifest",
      "version_code",
      "version_name",
      "shared_resources",
      "create_density_splits",
      "split_languages",
      "extensions_to_not_compress",
    ])
    if (defined(invoker.asset_location)) {
      asset_dir = invoker.asset_location
    }
    output_resource_packaged_apk_path = _resource_packaged_apk_path
  }

  if (incremental_install) {
  _generate_incremental_manifest_target_name =
      "${target_name}_incremental_generate_manifest"
  _incremental_android_manifest =
      get_label_info(_generate_incremental_manifest_target_name,
                     "target_gen_dir") + "/AndroidManifest.xml"
  action(_generate_incremental_manifest_target_name) {
    deps = _incremental_deps
    script = "//gn/addon/android_app/incremental_install/generate_android_manifest.py"
    depfile = "${target_gen_dir}/${target_name}.d"
    inputs = [
      _android_manifest,
    ]
    outputs = [
      depfile,
      _incremental_android_manifest,
    ]

    _rebased_src_manifest = rebase_path(_android_manifest, root_build_dir)
    _rebased_incremental_manifest =
        rebase_path(_incremental_android_manifest, root_build_dir)
    args = [
      "--src-manifest=$_rebased_src_manifest",
      "--out-manifest=$_rebased_incremental_manifest",
    ]
    if (disable_incremental_isolated_processes) {
      args += [ "--disable-isolated-processes" ]
    }
  }

  _incremental_package_resources_target_name =
      "${target_name}_incremental__package_resources"

  # TODO(agrieve): See if we can speed up this step by swapping the manifest
  # from the result of the main package_resources step.
  package_resources_helper(_incremental_package_resources_target_name) {
    forward_variables_from(invoker, [ "extensions_to_not_compress" ])
    deps =
        _incremental_deps + [ ":$_generate_incremental_manifest_target_name" ]
    android_manifest = _incremental_android_manifest
    resource_packaged_apk_path = _incremental_resource_packaged_apk_path
  }
  }

  package_target = "${target_name}__package"
  package_apk(package_target) {
    forward_variables_from(invoker, [ "native_libs_dir" ])
    deps = _deps + [ ":${_package_resources_target_name}" ]

    if (defined(_dex_path)) {
      dex_path = _dex_path
    }

    output_apk_path = _packaged_apk_path
    resource_packaged_apk_path = _resource_packaged_apk_path
  }

  if (incremental_install) {
  _incremental_package_target = "${target_name}_incremental__package"
  package_apk(_incremental_package_target) {
    _dex_target = "//gn/addon/android_app/incremental_install:bootstrap_java__dex"
    deps = _incremental_deps + [
             ":${_incremental_package_resources_target_name}",
             _dex_target,
           ]

    if (defined(_dex_path)) {
      dex_path =
          get_label_info(_dex_target, "target_gen_dir") + "/bootstrap.dex"
    }

    # TODO(agrieve): Add a placeholder .so for http://crbug.com/384638
    output_apk_path = _incremental_packaged_apk_path
    resource_packaged_apk_path = _incremental_resource_packaged_apk_path
  }
  }

  _finalize_apk_rule_name = "${target_name}__finalize"
  finalize_apk(_finalize_apk_rule_name) {
    input_apk_path = _packaged_apk_path
    output_apk_path = _final_apk_path
    keystore_path = _keystore_path
    keystore_name = _keystore_name
    keystore_password = _keystore_password
    rezip_apk = _load_library_from_apk

    public_deps = [
      # Generator of the _packaged_apk_path this target takes as input.
      ":$package_target",
    ]
  }

  if (incremental_install) {
  _incremental_finalize_apk_rule_name = "${target_name}_incremental__finalize"
  finalize_apk(_incremental_finalize_apk_rule_name) {
    input_apk_path = _incremental_packaged_apk_path
    output_apk_path = _incremental_final_apk_path
    keystore_path = _keystore_path
    keystore_name = _keystore_name
    keystore_password = _keystore_password

    public_deps = [
      ":$_incremental_package_target",
    ]
  }
  }

  _split_deps = []

  template("finalize_split") {
    finalize_apk(target_name) {
      _config = invoker.split_config
      _type = invoker.split_type
      input_apk_path = "${_resource_packaged_apk_path}_${_config}"
      _output_paths = process_file_template(
              [ _final_apk_path ],
              "{{source_dir}}/{{source_name_part}}-${_type}-${_config}.apk")
      output_apk_path = _output_paths[0]
      keystore_path = _keystore_path
      keystore_name = _keystore_name
      keystore_password = _keystore_password
      deps = [
        ":${_package_resources_target_name}",
      ]
    }
  }

  foreach(_split, _split_densities) {
    _split_rule = "${target_name}__finalize_${_split}_split"
    finalize_split(_split_rule) {
      split_type = "density"
      split_config = _split
    }
    _split_deps += [ ":$_split_rule" ]
  }
  foreach(_split, _split_languages) {
    _split_rule = "${target_name}__finalize_${_split}_split"
    finalize_split(_split_rule) {
      split_type = "lang"
      split_config = _split
    }
    _split_deps += [ ":$_split_rule" ]
  }

  group(target_name) {
    public_deps = [ ":${_finalize_apk_rule_name}" ] + _split_deps
  }

  if (incremental_install) {
  group("${target_name}_incremental") {
    public_deps = [ ":${_incremental_finalize_apk_rule_name}" ] + _split_deps
  }
  }
}

# Generates a script in the output bin.java directory to run a java binary.
#
# Variables
#   deps:
#   main_class: The class containing the progam entry point.
#   jar_path: The path to the jar to run.
#   build_config: Path to .build_config for the jar (contains classpath).
#   wrapper_script_args: List of extra arguments to pass to the executable.
#
#   script_name: Name of the script to generate.
#
template("java_binary_script") {
  set_sources_assignment_filter([])
  forward_variables_from(invoker, [ "testonly" ])

  _main_class = invoker.main_class
  _build_config = invoker.build_config
  _jar_path = invoker.jar_path
  _script_name = invoker.script_name

  action(target_name) {
    script = "//gn/addon/android_app/create_java_binary_script.py"
    depfile = "$target_gen_dir/$_script_name.d"
    java_script = "$root_build_dir/bin/$_script_name"
    inputs = [
      _build_config,
    ]
    outputs = [
      depfile,
      java_script,
    ]
    forward_variables_from(invoker, [ "deps" ])
    _rebased_build_config = rebase_path(_build_config, root_build_dir)
    args = [
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--output",
      rebase_path(java_script, root_build_dir),
      "--classpath=@FileArg($_rebased_build_config:java:full_classpath)",
      "--jar-path",
      rebase_path(_jar_path, root_build_dir),
      "--main-class",
      _main_class,
    ]
    if (defined(invoker.wrapper_script_args)) {
      args += [ "--" ] + invoker.wrapper_script_args
    }
  }
}


# Process java prebuilt jar, generate the ijar for the jar.
# proguard java code if needed.
#
# Variables
#   deps:
#   input_jar_path:
#   build_config:
#   proguard_preprocess:
#   proguard_config:
#
#   output_jar_path:
#
template("create_ijar") {
  set_sources_assignment_filter([])
  forward_variables_from(invoker, [ "testonly" ])

  _input_jar_path = invoker.input_jar_path
  _output_jar_path = invoker.output_jar_path
  _output_ijar_path = get_path_info(_output_jar_path, "dir") + "/" +
                      get_path_info(_output_jar_path, "name") + ".interface.jar"

  assert(invoker.build_config != "")

  if (defined(invoker.proguard_preprocess) && invoker.proguard_preprocess) {
    _proguard_jar_path = "${rebased_android_sdk_root}/tools/proguard/lib/proguard.jar"
    _proguard_config_path = invoker.proguard_config
    _build_config = invoker.build_config
    _rebased_build_config = rebase_path(_build_config, root_build_dir)
    _output_jar_target = "${target_name}__proguard_process"
    action(_output_jar_target) {
      forward_variables_from(invoker,
                             [
                               "data_deps",
                               "deps",
                               "public_deps",
                             ])
      script = "//gn/addon/android_app/proguard.py"
      inputs = [
        android_sdk_jar,
        _proguard_jar_path,
        _build_config,
        _input_jar_path,
        _proguard_config_path,
      ]
      depfile = "${target_gen_dir}/${target_name}.d"
      outputs = [
        depfile,
        _output_jar_path,
      ]
      args = [
        "--depfile",
        rebase_path(depfile, root_build_dir),
        "--proguard-path",
        rebase_path(_proguard_jar_path, root_build_dir),
        "--input-path",
        rebase_path(_input_jar_path, root_build_dir),
        "--output-path",
        rebase_path(_output_jar_path, root_build_dir),
        "--proguard-config",
        rebase_path(_proguard_config_path, root_build_dir),
        "--classpath",
        rebased_android_sdk_jar,
        "--classpath=@FileArg($_rebased_build_config:javac:classpath)",
      ]
    }
  } else {
    _output_jar_target = "${target_name}__copy_jar"
    copy(_output_jar_target) {
      forward_variables_from(invoker,
                             [
                               "data_deps",
                               "deps",
                               "public_deps",
                             ])
      sources = [
        _input_jar_path,
      ]
      outputs = [
        _output_jar_path,
      ]
    }
  }

  generate_interface_jar("${target_name}__ijar") {
    input_jar = _output_jar_path
    output_jar = _output_ijar_path
    deps = [
      ":$_output_jar_target",
    ]
  }

  group(target_name) {
    forward_variables_from(invoker, [ "visibility" ])
    public_deps = [
      ":${target_name}__ijar",
      ":$_output_jar_target",
    ]
  }
}

# Merges all dependency jars and a list of jars into a single jar
#
# Variables
#   deps:
#   build_config:
#   jar_list:
#
#   output_jar_path:
#
template("fat_jar") {
    action(target_name) {
      assert(defined(invoker.build_config) || defined(invoker.jar_list))
      assert(defined(invoker.output_jar_path))

      forward_variables_from(invoker,
                           [
                             "deps",
                             "testonly",
                           ])
      script = "//gn/addon/android_app/fat_jar.py"
      depfile = "$target_gen_dir/$target_name.d"

      outputs = [
        depfile,
        invoker.output_jar_path,
      ]

      args = [
        "--depfile",
        rebase_path(depfile, root_build_dir),
        "--output",
        rebase_path(invoker.output_jar_path, root_build_dir),
        
      ]

      inputs = []
      if (defined(invoker.build_config)) {
        inputs += [
          invoker.build_config,
        ]
        _rebased_build_config = rebase_path(invoker.build_config, root_build_dir)
        args += [
          "--inputs=@FileArg($_rebased_build_config:dist_jar:dependency_jars)",
        ]
      }
      
      if (defined(invoker.jar_list)) {
        inputs += invoker.jar_list
        _rebased_jar_list = rebase_path(invoker.jar_list, root_build_dir)
        args += [ "--inputs=$_rebased_jar_list" ]
      }
    }
}

template("java_prebuilt_impl") {
  set_sources_assignment_filter([])
  forward_variables_from(invoker, [ "testonly" ])
  _supports_android =
      defined(invoker.supports_android) && invoker.supports_android
  _forward_dex = _supports_android 
           && defined(invoker.forward_dex) && invoker.forward_dex

  assert(defined(invoker.jar_path))
  _base_path = "${target_gen_dir}/$target_name"

  # Jar files can be needed at runtime (by Robolectric tests or java binaries),
  # so do not put them under gen/.
  target_dir_name = get_label_info(":$target_name", "dir")
  _jar_path = "$root_out_dir/lib.java$target_dir_name/$target_name.jar"
  _build_config = _base_path + ".build_config"

  if (_forward_dex) {
    _dex_path = _base_path + ".dex.jar"
  }
  _deps = []
  if (defined(invoker.deps)) {
    _deps = invoker.deps
  }
  _jar_deps = []
  if (defined(invoker.jar_dep)) {
    _jar_deps = [ invoker.jar_dep ]
  }

  _template_name = target_name

  build_config_target_name = "${_template_name}__build_config"
  process_jar_target_name = "${_template_name}__process_jar"
  if (_forward_dex) {
    dex_target_name = "${_template_name}__dex"
  }

  write_build_config(build_config_target_name) {
    type = "java_library"
    supports_android = _supports_android
    requires_android =
        defined(invoker.requires_android) && invoker.requires_android

    deps = _deps
    build_config = _build_config
    jar_path = _jar_path
    if (_forward_dex) {
      dex_path = _dex_path
    }
  }

  create_ijar(process_jar_target_name) {
    visibility = [ ":$_template_name" ]
    if (_forward_dex) {
      visibility += [ ":$dex_target_name" ]
    }

    if (defined(invoker.proguard_preprocess) && invoker.proguard_preprocess) {
      proguard_preprocess = true
      proguard_config = invoker.proguard_config
    }

    build_config = _build_config
    input_jar_path = invoker.jar_path
    output_jar_path = _jar_path

    deps = [ ":$build_config_target_name" ] + _deps + _jar_deps
  }

  if (_forward_dex) {
    dex(dex_target_name) {
      sources = [
        _jar_path,
      ]
      output = _dex_path
      deps = [ ":$process_jar_target_name" ] + _deps + _jar_deps
    }
  }

  if (defined(invoker.main_class)) {
    binary_script_target_name = "${_template_name}__java_binary_script"
    java_binary_script(binary_script_target_name) {
      build_config = _build_config
      jar_path = _jar_path
      main_class = invoker.main_class
      script_name = _template_name
      deps = [
        ":$build_config_target_name",
      ]
    }
  }

  group(target_name) {
    forward_variables_from(invoker, [ "data_deps" ])
    deps = [
      ":$process_jar_target_name",
    ]
    if (_forward_dex) {
      deps += [ ":$dex_target_name" ]
    }
    data_deps = []
    if (defined(invoker.data_deps)) {
      data_deps += invoker.data_deps
    }
    if (defined(invoker.main_class)) {
      data_deps += [ ":$binary_script_target_name" ]
    }
  }
}

# Compiles and jars a set of java files.
#
# Outputs:
#  $jar_path.jar
#  $jar_path.interface.jar
#
# Variables
#   java_files: List of .java files to compile.
#   java_deps: List of java dependencies. These should all have a .jar output
#     at "${target_gen_dir}/${target_name}.jar.
#   srcjar_deps: List of srcjar dependencies. The .java files contained in the
#     dependencies srcjar outputs will be compiled and added to the output jar.
#   jar_path: Use this to explicitly set the output jar path. Defaults to
#     "${target_gen_dir}/${target_name}.jar.
template("compile_java") {
  set_sources_assignment_filter([])
  forward_variables_from(invoker, [ "testonly" ])

  assert(defined(invoker.java_files))
  assert(defined(invoker.build_config))
  assert(defined(invoker.jar_path))

  _java_files = invoker.java_files
  _final_jar_path = invoker.jar_path
  _intermediate_jar_path = "$target_gen_dir/$target_name.initial.jar"

  _build_config = invoker.build_config

  _jar_excluded_patterns = []
  if (defined(invoker.jar_excluded_patterns)) {
    _jar_excluded_patterns += invoker.jar_excluded_patterns
  }

  _supports_android = true
  if (defined(invoker.supports_android)) {
    _supports_android = invoker.supports_android
  }

  _manifest_entries = []
  if (defined(invoker.manifest_entries)) {
    _manifest_entries = invoker.manifest_entries
  }

  _srcjar_deps = []
  if (defined(invoker.srcjar_deps)) {
    _srcjar_deps += invoker.srcjar_deps
  }

  _java_srcjars = []
  if (defined(invoker.srcjars)) {
    _java_srcjars = invoker.srcjars
  }

  foreach(dep, _srcjar_deps) {
    _dep_gen_dir = get_label_info(dep, "target_gen_dir")
    _dep_name = get_label_info(dep, "name")
    _java_srcjars += [ "$_dep_gen_dir/$_dep_name.srcjar" ]
  }

  # Mark srcjar_deps as used.
  assert(_srcjar_deps == [] || true)

  _rebased_build_config = rebase_path(_build_config, root_build_dir)
  _rebased_jar_path = rebase_path(_intermediate_jar_path, root_build_dir)

  javac_target_name = "${target_name}__javac"
  finish_target_name = "${target_name}__finish"
  final_target_name = target_name

  action(javac_target_name) {
    script = "//gn/addon/android_app/javac.py"
    depfile = "$target_gen_dir/$target_name.d"
    deps = _srcjar_deps
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }

    outputs = [
      depfile,
      _intermediate_jar_path,
      _intermediate_jar_path + ".md5.stamp",
    ]
    sources = _java_files + _java_srcjars
    inputs = [
      _build_config,
    ]

    _rebased_java_srcjars = rebase_path(_java_srcjars, root_build_dir)
    _rebased_depfile = rebase_path(depfile, root_build_dir)
    args = [
      "--depfile=$_rebased_depfile",
      "--use-ijars",
      "--classpath=@FileArg($_rebased_build_config:javac:classpath)",
      "--jar-path=$_rebased_jar_path",
      "--java-srcjars=$_rebased_java_srcjars",
      "--java-srcjars=@FileArg($_rebased_build_config:javac:srcjars)",
      "--jar-excluded-classes=$_jar_excluded_patterns",
    ]
    args += [
      "--java-source=$javac_source",
      "--java-target=$javac_target",
    ]
    if (incremental_javac) {
      args += [ "--incremental" ]
    }
    if (_supports_android) {
      deps += [ "//gn/addon/android_app:android_ijar" ]
      _android_sdk_ijar = "$root_out_dir/lib.java/android.interface.jar"
      inputs += [ _android_sdk_ijar ]
      _rebased_android_sdk_ijar = rebase_path(_android_sdk_ijar, root_build_dir)
      args += [ "--bootclasspath=$_rebased_android_sdk_ijar" ]
    }
    foreach(e, _manifest_entries) {
      args += [ "--manifest-entry=" + e ]
    }

    _java_files_list = "$target_out_dir/${target_name}__java_files"
    write_file(_java_files_list, rebase_path(_java_files, root_build_dir))
    args += [ "@" + rebase_path(_java_files_list, root_build_dir) ]
  }

  create_ijar(finish_target_name) {
    visibility = [ ":$final_target_name" ]

    build_config = _build_config
    input_jar_path = _intermediate_jar_path
    output_jar_path = _final_jar_path
    if (defined(invoker.proguard_preprocess) && invoker.proguard_preprocess) {
      proguard_preprocess = invoker.proguard_preprocess
      proguard_config = invoker.proguard_config
    }
    deps = [
      ":$javac_target_name",
    ]
  }

  group(final_target_name) {
    forward_variables_from(invoker, [ "visibility" ])
    public_deps = [
      ":$finish_target_name",
    ]
  }
}

template("java_library_impl") {
  set_sources_assignment_filter([])
  forward_variables_from(invoker, [ "testonly" ])

  assert(
      defined(invoker.java_files) || defined(invoker.java_in_dir) ||
      defined(invoker.srcjars) || defined(invoker.srcjar_deps))
  _base_path = "$target_gen_dir/$target_name"
  assert(_base_path != "" || true)  # Mark as used.

  # Jar files can be needed at runtime (by Robolectric tests or java binaries),
  # so do not put them under gen/.
  target_dir_name = get_label_info(":$target_name", "dir")
  _jar_path = "$root_out_dir/lib.java$target_dir_name/$target_name.jar"
  if (defined(invoker.jar_path)) {
    _jar_path = invoker.jar_path
  }
  _template_name = target_name

  _final_deps = []
  _final_datadeps = []
  if (defined(invoker.datadeps)) {
    _final_datadeps = invoker.datadeps
  }

  _supports_android =
      defined(invoker.supports_android) && invoker.supports_android
  _forward_dex = _supports_android 
           && defined(invoker.forward_dex) && invoker.forward_dex

  _requires_android =
      defined(invoker.requires_android) && invoker.requires_android
  assert(_requires_android || true)  # Mark as used.
  _run_findbugs = defined(invoker.run_findbugs) && invoker.run_findbugs
  assert(_run_findbugs || true)  # Mark as used.

  if (_forward_dex) {
    _dex_path = _base_path + ".dex.jar"
    if (defined(invoker.dex_path)) {
      _dex_path = invoker.dex_path
    }
  } else {
    if (defined(invoker.dex_path)) {
      assert(invoker.dex_path != "" || true)  # Mark as used.
    }
  }

  # Define build_config_deps which will be a list of targets required to
  # build the _build_config.
  if (defined(invoker.override_build_config)) {
    _build_config = invoker.override_build_config

    # When a custom build config file is specified, we need to use the deps
    # supplied by the invoker any time we reference the build config file.
    assert(defined(invoker.deps),
           "If you specify a build config file for " +
               "java_library_impl($target_name), you should " +
               "also specify the target that made it in the deps")
    build_config_deps = invoker.deps
  } else {
    _build_config = _base_path + ".build_config"
    build_config_target_name = "${_template_name}__build_config"
    build_config_deps = [ ":$build_config_target_name" ]

    write_build_config(build_config_target_name) {
      forward_variables_from(invoker, [ "deps" ])
      type = "java_library"
      supports_android = _supports_android
      requires_android = _requires_android
      bypass_platform_checks = defined(invoker.bypass_platform_checks) &&
                               invoker.bypass_platform_checks

      build_config = _build_config
      jar_path = _jar_path
      if (_forward_dex) {
        dex_path = _dex_path
      }
    }
  }

  _srcjar_deps = []
  if (defined(invoker.srcjar_deps)) {
    _srcjar_deps = invoker.srcjar_deps
  }

  _srcjars = []
  if (defined(invoker.srcjars)) {
    _srcjars = invoker.srcjars
  }

  _java_files = []
  if (defined(invoker.java_in_dir)) {
    _java_files_build_rel = []
    foreach(_java_dir, invoker.java_in_dir) {
      _src_dir = _java_dir + "/src"
      _src_dir_exists = exec_script("//gn/script/dir_exists.py",
                                  [ rebase_path(_src_dir, root_build_dir) ],
                                  "string")
      assert(_src_dir_exists == "False",
           "In GN, java_in_dir should be the fully specified java directory " +
               "(i.e. including the trailing \"/src\")")

      _java_files_build_rel +=
        exec_script("//gn/script/find.py",
                    [
                      "--pattern",
                      "*.java",
                      rebase_path(_java_dir, root_build_dir),
                    ],
                    "list lines")
    }
    _java_files += rebase_path(_java_files_build_rel, ".", root_build_dir)
  }
  if (defined(invoker.java_files)) {
    _java_files += invoker.java_files
  }
  assert(_java_files != [] || _srcjar_deps != [] || _srcjars != [])

  _compile_java_target = "${_template_name}__compile_java"
  _final_deps += [ ":$_compile_java_target" ]
  compile_java(_compile_java_target) {
    forward_variables_from(invoker,
                           [
                             "dist_jar_path",
                             "jar_excluded_patterns",
                             "manifest_entries",
                             "proguard_config",
                             "proguard_preprocess",
                           ])
    jar_path = _jar_path
    build_config = _build_config
    java_files = _java_files
    srcjar_deps = _srcjar_deps
    srcjars = _srcjars
    supports_android = _supports_android
    deps = build_config_deps
  }

  if (defined(invoker.main_class)) {
    _final_datadeps += [ ":${_template_name}__java_binary_script" ]
    java_binary_script("${_template_name}__java_binary_script") {
      forward_variables_from(invoker,
                             [
                               "main_class",
                               "wrapper_script_args",
                             ])
      build_config = _build_config
      jar_path = _jar_path
      script_name = _template_name
      deps = build_config_deps
    }
  }

  if (_forward_dex) {
    _final_deps += [ ":${_template_name}__dex" ]
    dex("${_template_name}__dex") {
      sources = [
        _jar_path,
      ]
      output = _dex_path
      deps = [
        ":$_compile_java_target",
      ]
    }
  }

  group(target_name) {
    forward_variables_from(invoker, [ "visibility" ])
    public_deps = _final_deps
    data_deps = _final_datadeps
  }
}



template("copy_ex") {
  set_sources_assignment_filter([])
  action(target_name) {
    inputs = []
    sources = []
    forward_variables_from(invoker,
                           [
                             "deps",
                             "inputs",
                             "sources",
                             "testonly",
                             "visibility",
                           ])
    script = "//gn/android/gyp/copy_ex.py"

    depfile = "$target_gen_dir/$target_name.d"
    outputs = [
      depfile,
    ]

    args = [
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--dest",
      rebase_path(invoker.dest, root_build_dir),
    ]
    rebased_sources = rebase_path(sources, root_build_dir)
    args += [ "--files=$rebased_sources" ]

    if (defined(invoker.clear_dir) && invoker.clear_dir) {
      args += [ "--clear" ]
    }

    if (defined(invoker.args)) {
      args += invoker.args
    }
  }
}

# Produces a single .dex.jar out of a set of Java dependencies.
template("deps_dex") {
  set_sources_assignment_filter([])
  build_config = "$target_gen_dir/${target_name}.build_config"
  build_config_target_name = "${target_name}__build_config"

  write_build_config(build_config_target_name) {
    forward_variables_from(invoker,
                           [
                             "deps",
                             "dex_path",
                           ])
    type = "deps_dex"
    build_config = build_config
  }

  rebased_build_config = rebase_path(build_config, root_build_dir)
  dex(target_name) {
    inputs = [
      build_config,
    ]
    output = invoker.dex_path
    dex_arg_key = "${rebased_build_config}:final_dex:dependency_dex_files"
    args = [ "--inputs=@FileArg($dex_arg_key)" ]
    if (defined(invoker.excluded_jars)) {
      excluded_jars = rebase_path(invoker.excluded_jars, root_build_dir)
      args += [ "--excluded-paths=${excluded_jars}" ]
    }
    deps = [
      ":$build_config_target_name",
    ]
  }
}

